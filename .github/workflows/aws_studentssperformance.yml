# This workflow will build and push a new container image to Amazon ECR,
# and then will deploy a new task definition to Amazon ECS, when there is a push to the "main" branch.
#
# To use this workflow, you will need to complete the following set-up steps:

name: Deploy Application to Amazon ECS

on:
  push:
    branches:
        - main
    paths-ignore:
        - 'README.md'

permissions:
  id-token: write
  contents: read

jobs:
    integration:
        name: Continuous Integration
        runs-on: ubuntu-latest
        steps:
            - name: Checkout Code
              run: actions/checkout@v5

            - name: Lint Code
              run: echo "Linting repository"

            - name: Run unit tests
              run: echo "Running unit tests"

    build-and-push-ecr-image:
        needs: integration
        runs-on: ubuntu-latest
        steps:
            - name: Checkout Code
              uses: actions/checkout@v5

            - name: Install Utilities
              run: |
                sudo apt-get update
                sudo apt-get install -y jq unzip

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v1
              with:
                aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                aws-region: ${{ secrets.AWS_REGION }}

            - name: Login to Amazon ECR
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v1

            - name: Build, tag, and push image to Amazon ECR
              id: build-image
              env:
                ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
                ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
                IMAGE_TAG: latest
              run: |
                # Build a docker container and
                # push it to ECR so that it can
                # be deployed to ECS.
                docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
                docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

    deployment:
        name: Continuous Deployment
        needs: build-and-push-ecr-image
        runs-on: self-hosted
        steps:
            - name: Checkout
              uses: actions/checkout@v5
           
            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v1
              with:
                aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                aws-region: ${{ secrets.AWS_REGION }}
            
            - name: Login to Amazon ECR
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v1

            - name: Pull latest images
              run: |
                docker pull ${{secrets.AWS_ECR_LOGIN_URI}}/${{ secrets.ECR_REPOSITORY_NAME }}:latest

            #
            # - name: Fill in the new image ID in the Amazon ECS task definition
            #   id: task-def
            #   uses: aws-actions/amazon-ecs-render-task-definition@v1
            #   with:
            #     task-definition: ${{ env.ECS_TASK_DEFINITION }}
            #     container-name: ${{ env.CONTAINER_NAME }}
            #     image: ${{ steps.build-image.outputs.image }}
            
            #
            # - name: Deploy Amazon ECS task definition
            #   uses: aws-actions/amazon-ecs-deploy-task-definition@v1
            #   with:
            #     task-definition: ${{ steps.task-def.outputs.task-definition }}
            #     service: ${{ env.ECS_SERVICE }}
            #     cluster: ${{ env.ECS_CLUSTER }}
            #     wait-for-service-stability: true

            - name: Run Docker Image to serve users
              run: |
                docker run -d -p 8080:8080 --ipc="host" --name=studentssperformance -e 'AWS_ACCESS_KEY_ID=${{ secrets.AWS_REGION }}' ${{secrets.AWS_ECR_LOGIN_URI}}/${{ secrets.ECR_REPOSITORY_NAME }}:latest

            - name: Clean previous images and containers
              run: |
                docker system prune -f